class {
	// Project root directory
	variables.cwd = expandPath(".") & "/";
	// List of required modules
	variables.required = [];

	/**
	 * Reads the requirements.txt file and returns a list of required modules
	 */
	function readRequirements() {
		try {
			var filePath = variables.cwd & "requirements.txt";
			var content = fileRead(filePath);
			return content
				.listToArray(char(10))
				// Strip inline comments and blanks
				.map(line => line.listFirst("##").trim())
				.filter(line => line.trim() != "")
				.map(line => {
					return {
						name: line.listFirst("@").trim(),
						version: line.listRest("@").len() ? line.listRest("@").trim() : "any"
					};
				});
		} catch (any e) {
			printLn("Error reading requirements: " & e.message);
			cliExit(1);
		}
	}

	/**
	 * Compare semantic versions (ignores "+build" suffix).
	 * Returns -1, 0, 1 for a<b, a==b, a>b
	 */
	function compareVersions(a, b) {
		if (!isSimpleValue(a)) a = "";
		if (!isSimpleValue(b)) b = "";
		var aCore = a.listFirst("+");
		var bCore = b.listFirst("+");
		var aParts = aCore.listToArray(".");
		var bParts = bCore.listToArray(".");
		var maxLen = aParts.len();
		if (bParts.len() > maxLen) maxLen = bParts.len();
		if (maxLen < 3) maxLen = 3;
		for (var i = 1; i <= maxLen; i++) {
			var aNum = i <= aParts.len() ? val(aParts[i]) : 0;
			var bNum = i <= bParts.len() ? val(bParts[i]) : 0;
			if (aNum > bNum) return 1;
			if (aNum < bNum) return -1;
		}
		return 0;
	}

	/**
	 * Checks for missing modules and installs them if needed
	 */
	function checkAndInstallModules(dryRun = false) {
		// Get list of installed modules
		var installedRaw = "";
		bx:execute variable="installedRaw" name="install-bx-module" arguments="--list";
		var installedModules = installedRaw.listToArray(char(10)).filter(line => line.trim() != "");

		// Build an index of installed modules: name -> version
		var installedIndex = {};
		installedModules.each(line => {
			line = line.trim();
			// Expect lines like: "✓ bx-jsoup (1.0.0+1)"; skip headers/others
			var hasCheck = line.find("✓") > 0;
			var hasParen = line.find("(") > 0 && line.find(")") > 0;
			if (!hasCheck || !hasParen) return;

			var before = line.listFirst("(");
			var name = before.listLast(" ").trim();
			var version = line.listRest("(").listFirst(")").trim();
			if (name.len() && version.len()) {
				installedIndex[name] = version;
			}
		});

		var missing = [];
		// Check each required module against the index
		variables.required.each(module => {
			var name = module.name;
			var requiredAny = module.version == "any";
			var requiredPrefix = requiredAny ? "" : module.version.listFirst("+");

			var isInstalled = structKeyExists(installedIndex, name);
			if (isInstalled) {
				if (!requiredAny) {
					var installedVersion = installedIndex[name];
					// If installed < required, mark for install/upgrade
					if (compareVersions(installedVersion, requiredPrefix) < 0) {
						missing.push(name & "@" & requiredPrefix);
					}
				}
			} else {
				missing.push(requiredAny ? name : name & "@" & requiredPrefix);
			}
		});

		// Install missing modules if any
		if (missing.len()) {
			var modulesList = missing.toList(" ");
			if (dryRun) {
				printLn("Dry run: would install/upgrade: " & modulesList);
			} else {
				printLn("Installing missing required modules: " & modulesList);
				bx:execute variable="installedRaw" name="install-bx-module" arguments=modulesList;
			}
		} else {
			printLn("All required modules are already installed.");
		}
	}

	/**
	 * Main entry point
	 */
	function main(args = []) {
		variables.required = readRequirements();

		// Parse flags
		var dryRun = false;
		if (isArray(args)) {
			args.each(a => {
				if ((a & "").trim() == "--dry-run" || (a & "").trim() == "-n") dryRun = true;
			});
		}

		printLn("Checking for required modules..." & (dryRun ? " (dry run)" : ""));
		checkAndInstallModules(dryRun);
		cliExit(0);
	}
}
